{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\msdtt\\\\OneDrive\\\\Documents\\\\amai_hr_next_js_hasura\\\\amai-hr\\\\context\\\\auth.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { createContext, useReducer, useContext, useEffect } from \"react\";\nimport createPersistedState from \"use-persisted-state\";\nconst AuthDispatchContext = /*#__PURE__*/createContext();\nconst AuthStateContext = /*#__PURE__*/createContext();\nconst usePersistedAuthState = createPersistedState(\"AMAI_AUTH\");\nconst LOGIN_SUCCESS = \"LOGIN_SUCCESS\";\nconst UPDATE_USER = \"UPDATE_USER\";\nconst LOGOUT = \"LOGOUT\";\nconst initialState = {\n  isAuthenticated: false,\n  user: null,\n  token: null,\n  save_last_seen: false,\n  notification: null\n};\n\nfunction reducer(state, {\n  payload,\n  type\n}) {\n  switch (type) {\n    case LOGIN_SUCCESS:\n      return _objectSpread(_objectSpread(_objectSpread({}, state), payload), {}, {\n        isAuthenticated: true,\n        notification: true\n      });\n\n    case UPDATE_USER:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        user: _objectSpread(_objectSpread(_objectSpread({}, state.user), payload), state.notification)\n      });\n\n    case LOGOUT:\n      return initialState;\n\n    default:\n      throw new Error(`Unhandled action type ${type}`);\n  }\n}\n\nfunction AuthProvider({\n  children\n}) {\n  const [savedAuthState, saveAuthState] = usePersistedAuthState(initialState);\n  const {\n    0: state,\n    1: dispatch\n  } = useReducer(reducer, savedAuthState);\n  useEffect(() => {\n    saveAuthState(state);\n  }, [state, saveAuthState]);\n\n  const login = async ({\n    email,\n    password,\n    save_last_seen\n  }) => {\n    const res = await fetch(\"/api/login\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        email,\n        password\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    const json = await res.json();\n    if (!res.ok) throw new Error(json === null || json === void 0 ? void 0 : json.message);\n\n    const {\n      token\n    } = json,\n          user = _objectWithoutProperties(json, [\"token\"]);\n\n    dispatch({\n      type: LOGIN_SUCCESS,\n      payload: {\n        token,\n        user,\n        save_last_seen,\n        notification\n      }\n    });\n  };\n\n  const register = async ({\n    name,\n    last_name,\n    email,\n    domain,\n    phone_number,\n    password,\n    save_last_seen\n  }) => {\n    const res = await fetch(\"/api/register\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        last_name,\n        email,\n        domain,\n        phone_number,\n        password\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }); // const json = await res.json();\n    // if (!res.ok) throw new Error(json?.message);\n    // const { token, ...user } = json;\n    // dispatch({ type: LOGIN_SUCCESS, payload: { token, user, save_last_seen } });\n  };\n\n  const updateUser = payload => dispatch({\n    type: UPDATE_USER,\n    payload\n  });\n\n  const logout = () => dispatch({\n    type: LOGOUT\n  });\n\n  return __jsx(AuthDispatchContext.Provider, {\n    value: {\n      login,\n      register,\n      updateUser,\n      logout\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 5\n    }\n  }, __jsx(AuthStateContext.Provider, {\n    value: state,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 7\n    }\n  }, children));\n}\n\nfunction useAuthDispatch() {\n  const context = useContext(AuthDispatchContext);\n  if (context === undefined) throw new Error(\"useAuthDispatch must be used within an AuthProvider\");\n  return context;\n}\n\nfunction useAuthState() {\n  const context = useContext(AuthStateContext);\n  if (context === undefined) throw new Error(\"useAuthState must be used within an AuthProvider\");\n  return context;\n}\n\nexport { AuthProvider, useAuthDispatch, useAuthState };","map":{"version":3,"sources":["C:/Users/msdtt/OneDrive/Documents/amai_hr_next_js_hasura/amai-hr/context/auth.js"],"names":["createContext","useReducer","useContext","useEffect","createPersistedState","AuthDispatchContext","AuthStateContext","usePersistedAuthState","LOGIN_SUCCESS","UPDATE_USER","LOGOUT","initialState","isAuthenticated","user","token","save_last_seen","notification","reducer","state","payload","type","Error","AuthProvider","children","savedAuthState","saveAuthState","dispatch","login","email","password","res","fetch","method","body","JSON","stringify","headers","json","ok","message","register","name","last_name","domain","phone_number","updateUser","logout","useAuthDispatch","context","undefined","useAuthState"],"mappings":"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","sourcesContent":["import { createContext, useReducer, useContext, useEffect } from \"react\";\nimport createPersistedState from \"use-persisted-state\";\n\nconst AuthDispatchContext = createContext();\nconst AuthStateContext = createContext();\n\nconst usePersistedAuthState = createPersistedState(\"AMAI_AUTH\");\n\nconst LOGIN_SUCCESS = \"LOGIN_SUCCESS\";\nconst UPDATE_USER = \"UPDATE_USER\";\nconst LOGOUT = \"LOGOUT\";\n\nconst initialState = {\n  isAuthenticated: false,\n  user: null,\n  token: null,\n  save_last_seen: false,\n  notification: null,\n};\n\nfunction reducer(state, { payload, type }) {\n  switch (type) {\n    case LOGIN_SUCCESS:\n      return {\n        ...state,\n        ...payload,\n        isAuthenticated: true,\n        notification: true,\n      };\n    case UPDATE_USER:\n      return {\n        ...state,\n        user: {\n          ...state.user,\n          ...payload,\n          ...state.notification,\n        },\n      };\n    case LOGOUT:\n      return initialState;\n    default:\n      throw new Error(`Unhandled action type ${type}`);\n  }\n}\n\nfunction AuthProvider({ children }) {\n  const [savedAuthState, saveAuthState] = usePersistedAuthState(initialState);\n  const [state, dispatch] = useReducer(reducer, savedAuthState);\n\n  useEffect(() => {\n    saveAuthState(state);\n  }, [state, saveAuthState]);\n\n  const login = async ({ email, password, save_last_seen }) => {\n    const res = await fetch(\"/api/login\", {\n      method: \"POST\",\n      body: JSON.stringify({ email, password }),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n\n    const json = await res.json();\n\n    if (!res.ok) throw new Error(json?.message);\n\n    const { token, ...user } = json;\n\n    dispatch({\n      type: LOGIN_SUCCESS,\n      payload: { token, user, save_last_seen, notification },\n    });\n  };\n\n  const register = async ({\n    name,\n    last_name,\n    email,\n    domain,\n    phone_number,\n    password,\n    save_last_seen,\n  }) => {\n    const res = await fetch(\"/api/register\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        last_name,\n        email,\n        domain,\n        phone_number,\n        password,\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n\n    // const json = await res.json();\n\n    // if (!res.ok) throw new Error(json?.message);\n\n    // const { token, ...user } = json;\n\n    // dispatch({ type: LOGIN_SUCCESS, payload: { token, user, save_last_seen } });\n  };\n\n  const updateUser = (payload) => dispatch({ type: UPDATE_USER, payload });\n\n  const logout = () => dispatch({ type: LOGOUT });\n\n  return (\n    <AuthDispatchContext.Provider\n      value={{ login, register, updateUser, logout }}\n    >\n      <AuthStateContext.Provider value={state}>\n        {children}\n      </AuthStateContext.Provider>\n    </AuthDispatchContext.Provider>\n  );\n}\n\nfunction useAuthDispatch() {\n  const context = useContext(AuthDispatchContext);\n\n  if (context === undefined)\n    throw new Error(\"useAuthDispatch must be used within an AuthProvider\");\n\n  return context;\n}\n\nfunction useAuthState() {\n  const context = useContext(AuthStateContext);\n\n  if (context === undefined)\n    throw new Error(\"useAuthState must be used within an AuthProvider\");\n\n  return context;\n}\n\nexport { AuthProvider, useAuthDispatch, useAuthState };\n"]},"metadata":{},"sourceType":"module"}